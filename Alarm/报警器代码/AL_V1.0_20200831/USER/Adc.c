#include "includes.h"

ADC_ADJUST adc_adjust;				//ADC校准参数

static  OS_EVENT   *AdcMutex;
static void AdcLock(void)
{
	INT8U  err;
	
	if(AdcMutex == 0)
	{
		AdcMutex = OSMutexCreate(RES_ADC_MUTEX_PRIO, &err);
	}
	
	OSMutexPend(AdcMutex,0,&err);
}
static void AdcUnlock(void)
{	
	OSMutexPost(AdcMutex);
}

//==================================================================================================
//| 函数名称 | AdcConfig 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | ADC配置函数
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：郑海    时间：2014-08-27 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
void AdcConfig(void)
{
	GPIO_InitTypeDef GPIO_InitStruct;
	ADC_InitTypeDef ADC_InitStruct;
	
	//GPIO和ADC1时钟配置
	RCC_APB2PeriphClockCmd(AD_I1_PORT_RCC| AD_12V_PORT_RCC| ADC1_RCC, ENABLE);

	//GPIO配置为ADC模式
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_10MHz;
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AIN;
			
	GPIO_InitStruct.GPIO_Pin = AD_12V_PIN|AD_LINEA_PIN|AD_LINEB_PIN|AD_COMOUT_PIN;
	GPIO_Init(AD_12V_PORT, &GPIO_InitStruct);
    
 	GPIO_InitStruct.GPIO_Pin = AD_I1_PIN|AD_I2_PIN|AD_LINEAA_PIN;
	GPIO_Init(AD_I1_PORT, &GPIO_InitStruct); 
     	
	RCC_ADCCLKConfig(RCC_PCLK2_Div6);//手册要求ADC的频率不能超时14M
	
	//ADC1参数配置
    ADC_InitStruct.ADC_Mode = ADC_Mode_Independent;//独立模式
	ADC_InitStruct.ADC_ScanConvMode = ENABLE;//模数转换为单通道模式
	ADC_InitStruct.ADC_ContinuousConvMode = DISABLE;	  //不连续转换
	ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;	 //不用外部触发启动
	ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStruct.ADC_NbrOfChannel = 1;	  //通道为1
	ADC_Init(ADC1, &ADC_InitStruct);
	
	  
	/* Enable ADC1 */
	ADC_Cmd(ADC1, ENABLE);//使能ADC1
	
	/* Enable ADC1 reset calibaration register */   
	ADC_ResetCalibration(ADC1);//校准方式为复位校准

	/* Check the end of ADC1 reset calibration register */
	while(ADC_GetResetCalibrationStatus(ADC1));//等待复位校准结束
	
	/* Start ADC1 calibaration */
	ADC_StartCalibration(ADC1);

	/* Check the end of ADC1 calibration */
	while(ADC_GetCalibrationStatus(ADC1));	 
	
}
/**
  *************************************************************************************
  * @brief  把数据(16位)从大到小按顺序排列
  * @param  ptr_s:指针，指向排列前的数据
  * @param  ptr_d:指针，指向排序后的数据
  * @param  lenght:要排序的数据个数
  * @retval 无
  * @author ZH
  * @date   2014年9月10日
  * @note   无 
  *************************************************************************************
  */
void U16DataFallRank(u16* ptr_s, u16* ptr_d, u16 lenght)
{
	u16 i,j,temp;
	u8 flag_bit;
	
	if(lenght == 0)
	{
		return ;
	}
	memcpy((u8*)ptr_d, (u8*)ptr_s, lenght*2);
	for(i=0; i < lenght-1; i++)
	{
		flag_bit = 1;
		for(j=0; j < lenght-i-1; j++)
		{
			 if(*(ptr_d+j)<*(ptr_d+j+1))
			 {
				 flag_bit = 0 ;
				 temp = *(ptr_d+j) ;
				 *(ptr_d+j) = *(ptr_d+j+1);
				 *(ptr_d+j+1)= temp ;
			 }
		}
		if(flag_bit)//提前结束排序
		{
			break ;
		}		
	}
}
/**
  *************************************************************************************
  * @brief  获取ADC测量值
  * @param  adc1_channel:要测量的通道号。
  *         取值范围如下(与原理图对应)：
  *         @arg @b ADC_I1_CHANNEL
  *         @arg @b ADC_I2_CHANNEL
  *         @arg @b ADC_12V_CHANNEL
  *         @arg @b ADC_LINEA_CHANNEL
  *         @arg @b ADC_LINEB_CHANNEL
  *         @arg @b ADC_COMOUT_CHANNEL
  * @param  retry:重试次数,取值范围1-10
  * @param  lenght:要排序的数据个数
  * @retval 对应通道的ADC测量值
  * @author ZH
  * @date   2014年9月10日
  * @note   1.retry的值为0时，返回0，retry的值大于10时等效于10
  *         2.retry大于5时返回值为去掉2个最大值、2个最小值后求平均值，
  *           retry小于或等于5时返回值为平均值
  *************************************************************************************  
  */
u16 GetAdcValue(uint8_t adc1_channel, u8 retry)
{
	u16 ad_value = 0;
	u16 ad_temp[10], rank_temp[10];
	u8 i;
	
	if(retry == 0)
	{
		return 0;
	}
	else if(retry > 10)
	{
		retry = 10;
	}
	
	ADC_RegularChannelConfig(ADC1, (uint8_t)adc1_channel, 1, ADC_SampleTime_239Cycles5 );
 	for(i=0; i<retry; i++)
	{
		ADC_SoftwareStartConvCmd(ADC1, ENABLE);
		while(!ADC_GetFlagStatus(ADC1,ADC_FLAG_STRT)); //检查转换是否开始，1表示开始	
		ADC_SoftwareStartConvCmd(ADC1, ENABLE);
		while(!ADC_GetFlagStatus(ADC1,ADC_FLAG_STRT)); //检查转换是否开始，1表示开始
		
		ad_temp[i] = ADC_GetConversionValue(ADC1);  //读取DR时自动清标志
		ad_value += ad_temp[i];	
		if(i != (retry-1))//最后一次不用再延时
		{
			System72MDelay10us(1);
		}		
	}
	
	ADC_SoftwareStartConvCmd(ADC1, DISABLE);
	ADC_ClearFlag(ADC1,ADC_FLAG_STRT);//软件清除标志
	
	if(retry > 5)
	{
		ad_value = 0;
		U16DataFallRank(ad_temp, rank_temp, retry);//从大到小排序
		for(i=2; i < retry-2; i++)//去掉2个最大值、2个最小值后求平均值
		{
			ad_value += rank_temp[i];
		}
		ad_value /= (retry-4);
	}
	else
	{
		ad_value /= retry;
	}
	
	
	return ad_value;
}
/**
  *************************************************************************************
  * @brief  获取电源电压值
  * @param  无
  * @retval 测量值，单位mV
  * @author ZH
  * @date   2014年9月10日
  * @note   无
  *************************************************************************************
  */
u16 GetBatteryVoltage(void)
{
	u16 value;
	
	AdcLock();
	
	value = GetAdcValue(ADC_12V_CHANNEL,10);
	value *= DEFAULT_POWER_PARAM;
  	
	AdcUnlock();//释放资源
	
	return value;
}
/**
  *************************************************************************************
  * @brief  LINA-LINB之间的AD测量差值
  * @param  无
  * @retval AD测量差值
  * @author ZH
  * @date   2014年9月10日
  * @note   无
  *************************************************************************************  
  */
s16 GetLinABAdcValue(void)
{
	u16 lina,linb;
	s16 value = 0;

	AdcLock();//申请资源
	lina = GetAdcValue(ADC_LINEA_CHANNEL, 10);
	linb = GetAdcValue(ADC_LINEB_CHANNEL, 10);	
	value = linb - lina;
	AdcUnlock();//释放资源
	return value;
}

/**
  *************************************************************************************
  * @brief  根据ADC测量值，计算总线电压值(有正负值)
  * @param  无
  * @retval 电压值
  * @author ZH
  * @date   2014年9月10日
  * @note   无
  *************************************************************************************  
  */
s16 GetBusVoltageFromAdcValue(s16 AdcValue)
{
	u16 Value = 0;
	int voltage;
	
	if(AdcValue<0)
	{
		Value = -AdcValue;
	}
	else
	{
		Value = AdcValue;
	}

	if((u16)(adc_adjust.linab.k*1000) == 0)
	{
		voltage = (int)(Value*DEFAULT_ADC_PARAM);
	}
	else
	{
		if(adc_adjust.linab.b&0x8000)
		{
			voltage = (s16)((float)Value*adc_adjust.linab.k - (adc_adjust.linab.b&0x7FFF));
		}
		else
		{
			voltage = (s16)((float)Value*adc_adjust.linab.k + (adc_adjust.linab.b&0x7FFF));
		}	
	}	
	
	if(voltage<0)
	{
		voltage = 0;
	}
	
	if(AdcValue < 0)
	{
		voltage = -voltage;
	}
	
	return voltage;
}
//==================================================================================================
//| 函数名称 | GetBusVoltage 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 获取LINA和LINB间电压差值
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 电池电压值，单位mV
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：郑海    时间：2013-08-25 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u16 GetBusVoltage(u8 retry, u16* AdcValue)
{
	u16 value = 0;
	u8 i;
	u16 ad_temp[10], rank_temp[10];

	
	if ((retry == 0) || (retry >10))
	{
		retry = 10;
	}
	for(i = 0; i<retry; i++)
	{
		ad_temp[i] = abs(GetLinABAdcValue());	
		if((i+1) <retry)
		{
			System72MDelay1ms(1);		
		}		
	}
	if(retry > 5)
	{
		U16DataFallRank(ad_temp, rank_temp, retry);//从大到小排序
		for(i=2; i < retry-2; i++)//去掉2个最大值、2个最小值后求平均值
		{
			value += rank_temp[i];
		}
		value /= (retry-4);		
	}
	else
	{
		for(i=0; i < retry; i++)//求平均值
		{
			value += ad_temp[i];
		}
		value /= retry;
	}
	if(AdcValue != NULL)
	{
		*AdcValue = value;
	}
	return abs(GetBusVoltageFromAdcValue(value));
}
/**
  *************************************************************************************
  * @brief  获取电压值
  * @param  adc1_channel:要测量的通道号
  *         取值范围如下(与原理图对应):
  *         @arg @b ADC_COMOUT_CHANNEL
  *         @arg @b ADC_LINEA_CHANNEL
  *         @arg @b ADC_LINEB_CHANNEL
  * @retval 测量值，单位mV
  * @author ZH
  * @date   2014年9月10日
  * @note   输入参数值不在范围内时返回值为0
  *************************************************************************************  
  */
u16 GetChannelxVoltage(u8 ADC_Channel_x, u8 retry)
{
	double bat;
	
	AdcLock();//申请资源
	
	bat = (double)GetAdcValue(ADC_Channel_x, retry);
	bat *= DEFAULT_ADC_PARAM ;//分压比80.6K/20K
	
	AdcUnlock();//释放资源
	
	return ((u16)bat);
}
/**
  *************************************************************************************
  * @brief  ADC测量值转换成电压或者电流
  * @param[in]  Adc：ADC测量值  
  * @param[in]  Adjust：校准参数
  * @param[in]  Default：默认参数  
  * @retval 电压或者电流值 
  * @author ZH
  * @date   2018年7月9日
  * @note   
  *************************************************************************************  
  */
u16 Adc2VoltageOrCurrent(u16 Adc, ADJUST_PARAMETER* Adjust, float Default)
{
	int value;
	
	if((u16)(Adjust->k*1000) == 0)
	{
		value = (int)(Adc*Default);
	}
	else
	{
		if(Adjust->b&0x8000)
		{
			value = (int)((float)Adc*Adjust->k - (Adjust->b&0x7FFF));
		}
		else
		{
			value = (int)((float)Adc*Adjust->k + (Adjust->b&0x7FFF));
		}		
	}
	if(value < 0)
	{
		value = 0;
	}
	return value;
}
//==================================================================================================
//| 函数名称 | GetBusCurrent 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 获取总线电流
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 总线漏电流
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：王超    时间：2020-08-28 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u16 GetBusCurrent(u8 rd_count, u16* AdcValue)
{
	u16 value;
	AdcLock();//申请资源
	IRANGE_L();//切换到小量程
	System72MDelay100us(10);//必须加，消除切换量程造成的抖动
    
	value = GetAdcValue(ADC_I2_CHANNEL,rd_count);//判断当前处于小量程还是大量程
	if(NULL != AdcValue)
	{
		*AdcValue = value;	//返回ADC测量值，主要用于电流校准
	}	
	if(value  <  3351)//小量程满量程是对应3V，大于90%时(对应2.7V)切换量程：3*90%/3.3*4096 = 3351
	{
		value = Adc2VoltageOrCurrent(value, &adc_adjust.current1, DEFAULT_I1_PARAM);
	}
	else
	{
		IRANGE_H();//切换到大量程
		System72MDelay100us(10);//必须加，消除切换量程造成的抖动
		value = GetAdcValue(ADC_I1_CHANNEL,rd_count);
	if(NULL != AdcValue)
	{
		*AdcValue = value;	//返回ADC测量值，主要用于电流校准
	}
	value = Adc2VoltageOrCurrent(value, &adc_adjust.current2, DEFAULT_I2_PARAM);	

	}

	AdcUnlock();//释放资源

	return value;
    
}
//==================================================================================================
//| 函数名称 | GetBusLeakCurrent 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 获取总线漏电流
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 总线漏电流
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：郑海    时间：2013-09-05 
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u16 GetBusLeakCurrent(u16* AdcValue)
{
	u8 i;
	u16 ad_temp[10], rank_temp[10];
	s32 value, ad_value = 0;

	AdcLock();//申请资源
	SW5V_H();
    VSHIFT_L();//切换到5V
	System72MDelay1ms(2);//电容放电
    
	for(i=0; i<10; i++)
	{
		System72MDelay100us(5);//延时500us
		//ad_temp[i] = GetBusLowCurrent(1, NULL);不能使用这个，因为在该函数中无法申请到ADC资源
		IRANGE_L();//切换到小量程
        value = GetAdcValue(ADC_I2_CHANNEL,4);//判断当前处于小量程还是大量程
		if(value < 3351)//小量程满量程是对应3V，大于90%时(对应2.7V)切换量程：3*90%/3.3*4096 = 3351
		{
			value = Adc2VoltageOrCurrent(value, &adc_adjust.current1, DEFAULT_I1_PARAM);			
		}
		else
		{
			IRANGE_H();//切换到大量程
            value = GetAdcValue(ADC_I1_CHANNEL,4);
			value = Adc2VoltageOrCurrent(value, &adc_adjust.current2, DEFAULT_I2_PARAM);		
		}
		if(value<0)
		{
			value = 0;
		}		
		ad_temp[i] = (u16)value;
	}
	
	SW5V_L();
	VSHIFT_H();	//切换到6.7
	
	U16DataFallRank(ad_temp, rank_temp, 10);//从大到小排序
	for(i=2; i < 8; i++)//去掉2个最大值、2个最小值后求平均值
	{
		ad_value += rank_temp[i];
	}
	ad_value /= 6;
	
	AdcUnlock();//释放资源
	if(NULL != AdcValue)
	{
		*AdcValue = ad_value;
	}
	return ad_value;
}

//==================================================================================================
//| 函数名称 | BusIsShort 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 检测总线是否短路
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 总线状态 1是短路 0是正常
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：王超    时间：2020-08-28
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 BusIsShort(void)
{
    u16 value;

    value = GetBusCurrent(10,NULL);
    if(value > 15000)//满量程为20mA,实际最大量程是19.8mA,选择19mA作为判断标准
    {     
        return 1;
    }    
    else
    {        
        return 0;
    }  
}

//==================================================================================================
//| 函数名称 | BusLeakIsShort 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 检测总线漏电流是否异常
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 总线状态 1是漏电流大 0是正常
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：王超    时间：2020-08-28
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 BusLeakIsShort(u16* current)
{
	u8 temp;
    u16 value;
    
    value  = GetBusLeakCurrent(NULL);
    *current = value; 
    
    if(value > 500)
    {
        OSTimeDly(100); 
        value  = GetBusLeakCurrent(NULL);
        if(value  > 500)
        {
            temp = 1;
        }
    }
    else
    {
        temp = 0;
    }
    return temp; 
}

//==================================================================================================
//| 函数名称 | DetIsInsert 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 检测是否有雷管接入
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 有雷管接入return 1 没有雷管接入return 0
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：王超    时间：2020-08-28
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 需要考虑线缆的电阻以及冲击电流稳定后的电流大小。需要改动(经过重新设计函数可以避免这两个问题)
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 DetIsInsert(void)
{     
    u16 value,value1,value2;
    
    value1 = EliminateBusCurrentErr();
    OSTimeDly(500);
    value2 = EliminateBusCurrentErr();
    value = abs(value2 - value1);
    
    if(value > 23)//一发雷管的电流大约是20uA，考虑到单片机采集到的电流精度不高，采用23uA作为判断依据
    {
        return 1;
    }
    return 0;   
}
//==================================================================================================
//| 函数名称 | BusCurrentIsZero 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 总线电流是否为零
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：王超    时间：2020-08-28
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 需要考虑线缆的电阻以及冲击电流稳定后的电流大小。需要改动
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u8 BusCurrentIsZero(void)
{
    if(EliminateBusCurrentErr() < 10)
    {
        return 1;
    }
    return 0;        
}
//==================================================================================================
//| 函数名称 | FirstDetInsert 
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 雷管接入发出提示音
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：王超    时间：2020-08-28
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 需要考虑线缆的电阻以及冲击电流稳定后的电流大小。需要改动
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
//u8 FirstDetInsert(void)
//{

//    if(BusCurrentIsZero() == 1)
//	{
//        if(DetIsInsert() == 1)
//        {
//            return 1;
//        }

//	}
//    return 0;
//}
//==================================================================================================
//| 函数名称 |  EliminateBusCurrentErr
//|----------|--------------------------------------------------------------------------------------
//| 函数功能 | 消除总线电流误差，提高精度
//|----------|--------------------------------------------------------------------------------------
//| 输入参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 返回参数 | 无
//|----------|--------------------------------------------------------------------------------------       
//| 函数设计 | 编写人：王超    时间：2020-08-28
//|----------|-------------------------------------------------------------------------------------- 
//|   备注   | 需要考虑线缆的电阻以及冲击电流稳定后的电流大小。需要改动
//|----------|-------------------------------------------------------------------------------------- 
//| 修改记录 | 修改人：          时间：         修改内容： 
//==================================================================================================
u16  EliminateBusCurrentErr(void)
{
    u16 ad_value = 0;
    u16 ad_temp[10], rank_temp[10];
    u8 i;
    
    for(i=0;i<10;i++)
    {
        ad_temp[i] = GetBusCurrent(10,NULL);
    }
    
    U16DataFallRank(ad_temp, rank_temp, 10);
    for(i=2;i<8;i++)
    {
        ad_value += rank_temp[i];
    }
    ad_value /=6;
    
    return ad_value; 
}
